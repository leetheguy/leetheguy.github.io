// Generated by CoffeeScript 1.7.1
var initBoard;

initBoard = function() {
  var board;
  board = new cjs.Container();
  board = _.extend(board, {
    level: 0,
    map: [],
    tiles: [],
    rooms: [],
    spawnLevel: function() {
      this.level += 1;
      this.removeAllChildren();
      this.buildRoomArray();
      this.buildTileArray();
      return this.plotPaths();
    },
    buildRoomArray: function() {
      var emptyCount, hallCount, i, pointer, roomArray, roomCount, _i, _j, _k;
      this.rooms = Grid.populate(5, Room);
      emptyCount = _.random(3, 4);
      roomCount = _.random(7, 11);
      hallCount = 23 - (emptyCount + roomCount);
      pointer = 2;
      roomArray = _.chain(this.rooms).flatten().shuffle().value();
      roomArray[0].name = "entry";
      roomArray[1].name = "exit";
      for (i = _i = 1; 1 <= emptyCount ? _i <= emptyCount : _i >= emptyCount; i = 1 <= emptyCount ? ++_i : --_i) {
        roomArray[pointer].name = "empty";
        pointer += 1;
      }
      for (i = _j = 1; 1 <= roomCount ? _j <= roomCount : _j >= roomCount; i = 1 <= roomCount ? ++_j : --_j) {
        roomArray[pointer].name = "room";
        pointer += 1;
      }
      for (i = _k = 1; 1 <= hallCount ? _k <= hallCount : _k >= hallCount; i = 1 <= hallCount ? ++_k : --_k) {
        roomArray[pointer].name = "hall";
        pointer += 1;
      }
    },
    buildTileArray: function() {
      return this.tiles = Grid.populate(27, Tile);
    },
    plotPaths: function() {
      var column, path, pathConnected, paths, room, _i, _len, _ref, _results;
      path = [];
      _ref = this.rooms;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        column = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = column.length; _j < _len1; _j++) {
            room = column[_j];
            paths = [];
            pathConnected = false;
            if (!room.connected) {
              _results1.push((function() {
                var _results2;
                _results2 = [];
                while (!pathConnected) {
                  path = this.createPathFrom(room);
                  _results2.push(pathConnected = _.last(path).connected);
                }
                return _results2;
              }).call(this));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    createPathFrom: function(start) {
      var escapes, foo, last, path;
      start.seeking = true;
      path = [start];
      while (!(_.last(path).connected || _.isEmpty(this.findEscapes(_.last(path))))) {
        last = _.last(path);
        escapes = this.findEscapes(last);
        if (!_.isEmpty(escapes)) {
          path.push(this.getNextRoom(last));
        }
      }
      foo = 1;
      console.info(foo);
      return path;
    },
    findEscapes: function(room) {
      var east, escapes, north, south, west;
      escapes = {};
      if (room.coords.y > 0) {
        north = this.rooms[room.coords.x][room.coords.y - 1];
        if (!north.seeking && !(north.name === "empty")) {
          escapes.north = this.rooms[room.coords.x][room.coords.y - 1];
        }
      }
      if (room.coords.x < this.rooms.length - 1) {
        east = this.rooms[room.coords.x + 1][room.coords.y];
        if (!east.seeking && !(east.name === "empty")) {
          escapes.east = this.rooms[room.coords.x + 1][room.coords.y];
        }
      }
      if (room.coords.y < this.rooms.length - 1) {
        south = this.rooms[room.coords.x][room.coords.y + 1];
        if (!south.seeking && !(south.name === "empty")) {
          escapes.south = this.rooms[room.coords.x][room.coords.y + 1];
        }
      }
      if (room.coords.x > 0) {
        west = this.rooms[room.coords.x - 1][room.coords.y];
        if (!west.seeking && !(west.name === "empty")) {
          escapes.west = this.rooms[room.coords.x - 1][room.coords.y];
        }
      }
      return escapes;
    },
    getNextRoom: function(current) {
      var room;
      room = _.sample(this.findEscapes(current));
      room.seeking = true;
      return room;
    },
    populateStaticTiles: function() {},
    populateRoomTiles: function() {},
    populateDoors: function() {},
    hideRooms: function() {}
  });
  board.spawnLevel();
  return board;
};

//# sourceMappingURL=Board.map
